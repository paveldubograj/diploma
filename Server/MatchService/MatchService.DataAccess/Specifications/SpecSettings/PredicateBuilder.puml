@startuml
interface "ISpecification<T>" {
    Criteria : Expression<Func<T, bool>> <<get>>
    Includes : List<Expression<Func<T, object>>> <<get>>
}

abstract class "BaseSpecification<T>" {
    + BaseSpecification(criteria:Expression<Func<T, bool>>)
    + Criteria : Expression<Func<T, bool>> <<get>>
    + Includes : List<Expression<Func<T, object>>> <<get>>
}
"ISpecification<T>" "<T>" <|-- "BaseSpecification<T>"

class MatchSpecification {
    + MatchSpecification(criteria:Expression<Func<Match, bool>>)
    + {static} FilterMatch(CategoryId:string, StartTime:DateTime?, EndTime:DateTime?,\nTournamentId:string, Status:string) : MatchSpecification
}
"BaseSpecification<T>" "<Match>" <|-- MatchSpecification

class PredicateBuilder <<static>> {
    + {static} True() : Expression<Func<T, bool>>
    + {static} False() : Expression<Func<T, bool>>
    + {static} And(expr1:Expression<Func<T, bool>>,\nexpr2:Expression<Func<T, bool>>) : Expression<Func<T, bool>>
    + {static} Or(expr1:Expression<Func<T, bool>>,\nexpr2:Expression<Func<T, bool>>) : Expression<Func<T, bool>>
}

class SpecificationEvaluator <<static>> {
    + {static} ApplySpecification(query:IQueryable<T>,\nspec:ISpecification<T>) : IQueryable<T>
}
@enduml
